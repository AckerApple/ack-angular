{"version":3,"sources":["../src/AckQue.ts"],"names":[],"mappings":"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","file":"AckQue.js","sourceRoot":"","sourcesContent":["import { Injectable } from '@angular/core';\nimport { AckOffline } from './AckOffline';\n\n//const supportsNav = typeof(navigator)!='undefined'\n\n/** Que data based processes by associating name based handlers */\n export class AckQue extends AckOffline{\n  public handlers = []\n  \n  /** processes with associated that are typically awaiting internet access to complete processing */\n  get(name) {\n    return super.get(name)\n    .then(data => data && data['que'] ? data['que'] : [])\n  }\n\n  /** aka get */\n  getQue(name){\n    return this.get(name)\n  }\n\n  /** aka set */\n  setQue(name, que){\n    return this.set(name, que)\n  }\n\n  /** clears data-process based que of tasks */\n  /*clearQue(name) {\n    return super.clear(name)\n    .then(data => {\n      data['que'] = []\n      super.set(name, data)\n    })\n  }*/\n\n  /** add to qued data. Typically when offline, add post/put requests here and process them when back online */\n  que(name, queData) {\n    /*if(supportsNav && navigator.onLine) {\n      const registration = this.handlers.find( handler=>handler.name===name )\n      if(registration){\n        return Promise.resolve( registration.handler(queData) )\n      }\n    }*/\n\n    return super.get(name)\n    .then(data => {\n      data = data || {}\n      data['que'] = data['que'] || []\n      \n      if(queData.forEach){\n        queData.forEach(x=>{\n          data['que'].push( x )\n        })\n      }else{\n        data['que'].push( queData )\n      }\n      return super.set(name, data)\n    })\n  }\n\n  /** merge new que data overtop of existing que\n    @name:string\n    @que\n  */\n  set(name, queData) {\n    return this.que(name, queData)\n  }\n\n  dequeByIndex(name, index){\n    return this.getQue(name)\n    .then(array=>array.splice(index, 1) && array)\n    .then( array=>this.setQue(name, array) )\n  }\n\n  processQuedByIndex(name, index){\n    const handler = this.getQueHandlerByName(name)\n    const mem = {item:null, array:null, result:null}\n\n    return this.getQue(name)\n    .then(array=>{\n      mem.item = array.splice(index, 1)\n      mem.array = array\n    })\n    .then( ()=>this.handleQued(name, mem.item, handler))\n    .then( result=>mem.result=result )\n    .then( ()=>this.setQue(name, mem.array) )\n    .then( ()=>mem.result )\n  }\n\n  /** Most important. When a que of data-tasks is being processed, the approperiate handler must be registered here */\n  registerQueHandler(name, handler) {\n    //handler = handler || this.getQueHandler.bind(this)\n    this.handlers.push({name, handler})\n    return this\n  }\n\n  /** return functions */\n  getQueHandlerByName(name){\n    for(let i=this.handlers.length-1; i >= 0; --i){\n      if(this.handlers[i].name==name)return this.handlers[i].handler\n    }\n  }\n\n  handleQued(name, qued, handler){\n    return Promise.resolve( handler(qued) )\n  }\n\n  processQuedHandler(hand){\n    const results = []\n    const eachHandle = this.eachHandler(hand.name, hand.handler)\n\n    return this.get(hand.name)\n    .then( que => que.map(eachHandle) )\n    .then( r=>results.push.apply(results,r) )\n    .then( ()=>this.clear(hand.name) )\n    .then( ()=>results )\n  }\n\n  eachHandler(name, handler){\n    return data=>this.handleQued(name, data, handler)\n  }\n\n  /** call manually in app when back online */\n  processQue(){\n    const results = [], promises = []\n\n    this.handlers.forEach(hand=>\n      promises.push( this.processQuedHandler(hand) )\n    )\n\n    return Promise.all(promises)\n    .then(proms=>{\n      const results = []\n      proms.forEach( subArray=>results.push.apply(results, subArray) )\n      return Promise.all( results )//array of arrays is now one array\n    })\n  }\n\n  /*getQueHandler(item) {\n    return this.$http(item)\n  }*/\n\n  /**\n    Creates que handler. Returns self. Most likely, use newQueModel\n    @options - {\n      handler : dataArray=> - overrides $http posting for que processing\n      onData : data=> - callback fired everytime data is retrieved\n      expires: Number - how many milisecs can a saved transmission live in cache\n    }\n  */\n  /*newQueModel(name,options={}){\n    options.name = name\n    this.addQueModel(name, options)\n    return new QueModel(this, options)\n  }*/\n\n  /**\n    Creates que handler. Returns self. Most likely, use newQueModel\n    @options - {\n      handler : dataArray=> - overrides $http posting for que processing\n      onData : data=> - callback fired everytime data is retrieved\n    }\n  */\n  /*addQueModel(name,options={}){\n    return this.registerQueHandler(name, trans=>{\n      let prom = this.$http(trans)\n\n      if(options.onData){\n        prom = prom.then(response=>{\n          if(response.data){\n            options.onData(response.data)\n          }\n        })\n      }\n\n      return prom.catch(e=>this.ErrorHandler.record(e))\n    })\n  }*/\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n];\n}\n\n\n/**\n  @config {expires, allowExpired, name}\n*/\n/*\nclass QueModel{\n  constructor(AckOffline, config){\n    this.AckOffline = AckOffline\n    this.config = config\n  }\n\n  mergeConfig(config){\n    Object.assign(config, this.config)\n    this.config = config\n    return this\n  }\n\n  get(){\n    return this.AckOffline.get(this.config.name)\n  }\n\n  set(data){\n    return this.AckOffline.set(this.config.name, data)\n  }\n}*/\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}