{"ast":null,"code":"import { EventEmitter, ElementRef } from \"@angular/core\";\nimport * as i0 from \"@angular/core\";\nexport let FxOn = /*#__PURE__*/(() => {\n  class FxOn {\n    constructor(element) {\n      this.element = element;\n      this.fxThen = new EventEmitter();\n      this.fxTypes = [\"bounce\", \"flash\", \"pulse\", \"rubberBand\", \"shake\", \"swing\", \"tada\", \"wobble\", \"jello\", \"bounceIn\", \"bounceInDown\", \"bounceInLeft\", \"bounceInRight\", \"bounceInUp\"];\n    }\n\n    ngOnInit() {\n      Promise.resolve().then(() => this.update());\n    }\n\n    update() {\n      if (this.fxOn) {\n        this.onTrue();\n      } else {\n        this.onFalse();\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.fxOn && changes.fxOn.currentValue != null && changes.fxOn.currentValue != changes.fxOn.previousValue) {\n        this.update();\n      }\n\n      if (changes.fxClass && changes.fxClass.currentValue != changes.fxClass.previousValue) {\n        if (this.fxOn) {\n          removeClass(this.element.nativeElement, changes.fxClass.previousValue);\n          this.applyType();\n        } else {\n          this.removeType();\n        }\n      }\n    }\n\n    onFalse() {\n      this.removeType();\n\n      if (this.timeout) {\n        clearTimeout(this.timeout);\n        delete this.timeout;\n      }\n    }\n\n    removeType() {\n      const elm = this.element.nativeElement;\n      removeClass(elm, this.fxClass);\n\n      if (this.inlineTreated) {\n        elm.style.display = 'inline';\n        this.inlineTreated = false;\n      }\n    }\n\n    applyType() {\n      const elm = this.element.nativeElement;\n\n      if (elm.style && elm.style.display === 'inline' || getElementDefaultDisplay(elm) === 'inline') {\n        this.inlineTreated = true;\n        elm.style.display = 'inline-block';\n      }\n\n      addClass(elm, this.fxClass);\n    }\n\n    onTrue() {\n      this.applyType();\n\n      if (this.fxForMs) {\n        this.timeout = setTimeout(() => {\n          this.onFalse();\n          this.fxThen.emit();\n        }, this.fxForMs);\n      }\n    }\n\n  }\n\n  FxOn.ɵfac = function FxOn_Factory(t) {\n    return new (t || FxOn)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  FxOn.ɵdir = i0.ɵɵdefineDirective({\n    type: FxOn,\n    selectors: [[\"\", \"fxOn\", \"\"]],\n    inputs: {\n      fxOn: \"fxOn\",\n      fxClass: \"fxClass\",\n      fxForMs: \"fxForMs\"\n    },\n    outputs: {\n      fxThen: \"fxThen\"\n    },\n    exportAs: [\"FxOn\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FxOn;\n})();\nexport function hasClass(el, className) {\n  const names = className.split(\" \");\n\n  for (let x = names.length - 1; x >= 0; --x) {\n    if (el.classList) {\n      if (el.classList.contains(names[x])) {\n        continue;\n      }\n    } else {\n      if (el.className.match(new RegExp('(\\\\s|^)' + names[x] + '(\\\\s|$)'))) {\n        continue;\n      }\n    }\n\n    return false;\n  }\n\n  return true;\n}\nexport function addClass(el, className) {\n  className.split(' ').forEach(className => {\n    if (el.classList) {\n      el.classList.add(className);\n    } else if (!hasClass(el, className)) {\n      el.className += \" \" + className;\n    }\n  });\n}\nexport function removeClass(el, className) {\n  className.split(' ').forEach(className => {\n    if (el.classList) {\n      el.classList.remove(className);\n    } else if (hasClass(el, className)) {\n      var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)');\n      el.className = el.className.replace(reg, ' ');\n    }\n  });\n}\n\nfunction getElementDefaultDisplay(tag) {\n  var cStyle,\n      t = tag,\n      gcs = (\"getComputedStyle\" in window);\n  cStyle = (gcs ? window.getComputedStyle(t, \"\") : t.currentStyle).display;\n  return cStyle;\n}","map":null,"metadata":{},"sourceType":"module"}