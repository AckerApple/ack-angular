{"ast":null,"code":"import { BehaviorSubject } from \"rxjs\";\nimport { EventEmitter, IterableDiffers, IterableDiffer } from \"@angular/core\";\nimport { AckAggregate } from \"./AckAggregate.directive\";\nimport * as i0 from \"@angular/core\";\nexport let AckArray = /*#__PURE__*/(() => {\n  class AckArray {\n    constructor(_iterableDiffers) {\n      this._iterableDiffers = _iterableDiffers;\n      this.pushed = {};\n      this.inSort = false;\n      this.sortArray = [];\n      this.pageAt = 0;\n      this.pagesChange = new BehaviorSubject(null);\n      this.page = 0;\n      this.pageChange = new EventEmitter();\n      this.keyMapChange = new EventEmitter();\n      this.loopStart = new EventEmitter();\n      this.loopEach = new EventEmitter();\n      this.loopEnd = new EventEmitter();\n      this.arrayChange = new EventEmitter();\n\n      const f = this._iterableDiffers.find([]);\n\n      this.iterableDiffer = f.create();\n    }\n\n    ngOnDestroy() {\n      if (this.array$sub) {\n        this.array$sub.unsubscribe();\n      }\n    }\n\n    ngOnInit() {\n      if (this.keyMapChange.observers.length) {\n        if (!this.keyMap) {\n          Promise.resolve().then(() => {\n            this.keyMap = {};\n            this.keyMapChange.emit(this.keyMap);\n          });\n        }\n\n        this.pushCreateMap();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.AckAggregates) {\n        this.pushAggregates(this.AckAggregates);\n      }\n\n      this.inited = true;\n      Promise.resolve().then(() => this.loop(true));\n    }\n\n    ngDoCheck() {\n      if (!this.inited) return;\n      let changes = this.iterableDiffer.diff(this.array);\n\n      if (changes) {\n        Promise.resolve().then(() => this.loop(false));\n      }\n    }\n\n    ngOnChanges(changes) {\n      if (changes.array$) {\n        if (this.array$sub) {\n          this.array$sub.unsubscribe();\n          delete this.array$sub;\n        }\n\n        if (this.array$) {\n          this.array$sub = this.array$.subscribe(array => {\n            if (this.merge) {\n              mergeArrays(this.array, array, this.idKeys);\n            } else {\n              const reset = this.array != array;\n              this.array = array;\n              this.loop(reset);\n            }\n          });\n        }\n      }\n\n      let loop = changes.array ? true : false;\n\n      if (changes.pageAt) {\n        this.pushCreatePages();\n        loop = true;\n      }\n\n      if (this.inited && loop) {\n        Promise.resolve().then(() => this.loop(true));\n      }\n    }\n\n    pushAggregates(aggs) {\n      aggs.forEach(agg => {\n        let memory;\n\n        switch (agg.type) {\n          default:\n            {\n              this.loopStart.subscribe(() => memory = 0);\n              this.loopEach.subscribe(loop => {\n                const value = this.getItemValueByKeys(loop.item, agg.keys);\n\n                if (value) {\n                  memory = memory + value;\n                }\n              });\n              this.loopEnd.subscribe(() => {\n                agg.output = memory;\n                agg.outputChange.emit(memory);\n              });\n            }\n        }\n      });\n    }\n\n    getItemValueByKeys(item, keys) {\n      for (let x = 0; x < keys.length; ++x) {\n        let keyName = keys[x];\n        item = item[keyName];\n        if (item == null) return null;\n      }\n\n      return item;\n    }\n\n    loop(reset) {\n      if (!this.array) {\n        this.array = [];\n      }\n\n      this.loopStart.emit(reset);\n      const last = this.array.length;\n\n      for (let x = 0; x < last; ++x) {\n        this.loopEach.emit({\n          index: x,\n          item: this.array[x]\n        });\n      }\n\n      this.loopEnd.emit();\n    }\n\n    pushCreateMap() {\n      if (this.pushed.createMap) return;\n      this.pushed.createMap = true;\n      this.loopStart.subscribe(() => this.keyMap = {});\n      this.loopEach.subscribe(ob => {\n        let key = this.getItemId(ob.item);\n        this.keyMap[key] = ob.item;\n      });\n      this.loopEnd.subscribe(() => this.keyMapChange.emit(this.keyMap));\n    }\n\n    pushCreatePages() {\n      if (this.pushed.createPages) return;\n      this.pushed.createPages = true;\n      let pos = 0;\n      let last = 0;\n      this.loopStart.subscribe(reset => {\n        pos = 0;\n        last = this.array.length;\n\n        if (reset) {\n          this.pageChange.emit(this.page = 0);\n        }\n\n        this.pages = this.pages || [];\n        this.pages.length = 0;\n        this.pages.push([]);\n      });\n      this.loopEach.subscribe(ob => {\n        this.pages[pos].push(ob.item);\n\n        if (this.pages[pos].length == this.pageAt && ob.index < last - 1) {\n          this.pages.push([]);\n          ++pos;\n        }\n      });\n      this.loopEnd.subscribe(() => {\n        if (this.page && this.page >= this.pages.length) {\n          this.pageChange.emit(this.page = 0);\n        }\n\n        this.pagesChange.next(this.pages);\n      });\n    }\n\n    only(item) {\n      this.array.length = 0;\n      this.array.push(item);\n      this.arrayChange.emit(this.array);\n      this.loop(true);\n    }\n\n    getItemId(item) {\n      return this.idKeys && this.idKeys[0] && item[this.idKeys[0]];\n    }\n\n    getCompareArray() {\n      if (this.array && this.idKeys && this.idKeys.length) {\n        const idKey = this.idKeys[0];\n        return this.array.map(item => item[idKey]);\n      }\n\n      return this.array || [];\n    }\n\n    selected(item) {\n      return this.itemIndex(item) >= 0 ? true : false;\n    }\n\n    itemIndex(item) {\n      const array = this.getCompareArray();\n\n      for (let x = array.length - 1; x >= 0; --x) {\n        if (dataKeysMatch(array[x], item, this.idKeys)) {\n          return x;\n        }\n      }\n\n      return -1;\n    }\n\n    toggle(item) {\n      const index = this.itemIndex(item);\n\n      if (index >= 0) {\n        return this.splice(index);\n      }\n\n      return this.push(item);\n    }\n\n    push(item) {\n      this.param().push(item);\n      this.loop(false);\n      return this;\n    }\n\n    unshift(item) {\n      this.param().unshift(item);\n      return this;\n    }\n\n    splice(x, y = 1) {\n      this.param().splice(x, y);\n      this.loop(false);\n      return this;\n    }\n\n    param() {\n      if (!this.array) this.arrayChange.emit(this.array = []);\n      return this.array;\n    }\n\n    toggleSort(arrayKey, sortType) {\n      if (this.inSort) return false;\n      this.inSort = true;\n      let asc = false;\n\n      if (this.sortArray.length && this.sortArray[0].arrayKey) {\n        asc = !this.sortArray[0].asc;\n        this.sortArray[0] = {\n          arrayKey: arrayKey,\n          asc: !this.sortArray[0].asc\n        };\n      } else {\n        this.sortArray.unshift({\n          arrayKey: arrayKey,\n          asc: asc\n        });\n      }\n\n      const toKey = function (a, index = 0) {\n        const value = a[arrayKey[index]];\n\n        if (value == null || index == arrayKey.length - 1) {\n          return value;\n        }\n\n        return toKey(value, index + 1);\n      };\n\n      if (arrayKey.constructor != Array) {\n        arrayKey = [arrayKey];\n      }\n\n      const numberSort = !isNaN(sortType) || [\"int\", \"number\"].indexOf(sortType) >= 0;\n\n      if (numberSort) {\n        if (asc) {\n          this.array.sort((a, b) => Number(toKey(a)) - Number(toKey(b)));\n        } else {\n          this.array.sort((b, a) => Number(toKey(a)) - Number(toKey(b)));\n        }\n      } else {\n        switch (sortType) {\n          case \"date\":\n          case \"time\":\n          case \"datetime\":\n            if (asc) {\n              this.array.sort((a, b) => {\n                a = new Date(toKey(a, 0));\n                b = new Date(toKey(b, 0));\n                return a == \"Invalid Date\" || a > b ? -1 : b == \"Invalid Date\" || a < b ? 1 : 0;\n              });\n            } else {\n              this.array.sort((b, a) => {\n                a = new Date(toKey(a, 0));\n                b = new Date(toKey(b, 0));\n                return a == \"Invalid Date\" || a > b ? -1 : b == \"Invalid Date\" || a < b ? 1 : 0;\n              });\n            }\n\n            break;\n\n          default:\n            if (asc) {\n              this.array.sort((a, b) => String(toKey(a) || \"\").toLowerCase() > String(toKey(b) || \"\").toLowerCase() ? 1 : -1);\n            } else {\n              this.array.sort((b, a) => String(toKey(a) || \"\").toLowerCase() > String(toKey(b) || \"\").toLowerCase() ? 1 : -1);\n            }\n\n        }\n      }\n\n      if (this.sortArray.length > 3) {\n        this.sortArray.pop();\n      }\n\n      this.inSort = false;\n      this.loop(true);\n    }\n\n  }\n\n  AckArray.ɵfac = function AckArray_Factory(t) {\n    return new (t || AckArray)(i0.ɵɵdirectiveInject(i0.IterableDiffers));\n  };\n\n  AckArray.ɵdir = i0.ɵɵdefineDirective({\n    type: AckArray,\n    selectors: [[\"ack-array\"]],\n    contentQueries: function AckArray_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, AckAggregate, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.AckAggregates = _t);\n      }\n    },\n    inputs: {\n      pageAt: \"pageAt\",\n      pages: \"pages\",\n      page: \"page\",\n      keyMap: \"keyMap\",\n      idKeys: \"idKeys\",\n      merge: \"merge\",\n      array: \"array\",\n      array$: \"array$\"\n    },\n    outputs: {\n      pagesChange: \"pagesChange\",\n      pageChange: \"pageChange\",\n      keyMapChange: \"keyMapChange\",\n      arrayChange: \"arrayChange\"\n    },\n    exportAs: [\"AckArray\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return AckArray;\n})();\nexport function dataKeysMatch(ao, an, idKeys) {\n  for (let x = idKeys.length - 1; x >= 0; --x) {\n    let idKey = idKeys[x];\n\n    if (ao[idKey] != null && ao[idKey] !== an[idKey]) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexport function mergeArrays(arrayOriginal, arrayNew, idKeys) {\n  for (let x = arrayOriginal.length - 1; x >= 0; --x) {\n    let ao = arrayOriginal[x];\n    let an = arrayNew[x];\n\n    if (an && dataKeysMatch(ao, an, idKeys)) {\n      continue;\n    }\n\n    let found = false;\n\n    for (let xx = arrayNew.length - 1; xx >= 0; --xx) {\n      if (dataKeysMatch(ao, arrayNew[xx], idKeys)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (found) continue;\n    arrayOriginal.splice(x, 1);\n  }\n\n  for (let x = 0; x < arrayNew.length; ++x) {\n    let ao = arrayOriginal[x];\n    let an = arrayNew[x];\n    let found = false;\n\n    if (ao && dataKeysMatch(ao, an, idKeys)) {\n      mergeObjects(ao, an);\n      continue;\n    }\n\n    for (let xx = arrayOriginal.length - 1; xx >= 0; --xx) {\n      ao = arrayOriginal[xx];\n\n      if (dataKeysMatch(ao, an, idKeys)) {\n        mergeObjects(ao, an);\n        found = true;\n        continue;\n      }\n    }\n\n    if (found) {\n      continue;\n    }\n\n    arrayOriginal.splice(x, 0, an);\n  }\n}\n\nfunction mergeObjects(ao, an) {\n  for (let x in ao) {\n    delete ao[x];\n  }\n\n  Object.assign(ao, an);\n}","map":null,"metadata":{},"sourceType":"module"}