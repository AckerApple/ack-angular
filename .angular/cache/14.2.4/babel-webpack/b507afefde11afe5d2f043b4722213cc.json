{"ast":null,"code":"import { EventEmitter } from \"@angular/core\";\nimport { HttpParams, HttpEventType, HttpHeaders, HttpClient, HttpRequest } from \"@angular/common/http\";\nimport { AckCache } from \"./AckCache\";\nimport { AckQue } from \"./AckQue\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class TimeOutError {\n  constructor(message) {\n    Error[\"captureStackTrace\"](this, this.constructor);\n    this.name = this.constructor.name;\n    this.status = 504;\n    this.code = \"gateway_timeout\";\n    this.message = message || \"Could not connect to server or server did not respond in a timely manner. Please check internet connection and then try again.\";\n  }\n\n}\nexport let AckApi = /*#__PURE__*/(() => {\n  class AckApi {\n    constructor(HttpClient) {\n      this.HttpClient = HttpClient;\n      this.response = new EventEmitter();\n      this.Request = new EventEmitter();\n      this.AuthError = new EventEmitter();\n      this.ApiError = new EventEmitter();\n      this.AckCache = new AckCache();\n      this.AckQue = new AckQue();\n      this.config = {\n        baseUrl: '',\n        $http: {\n          method: \"GET\",\n          headers: {},\n          timeout: 6500\n        }\n      };\n      this.paramConfig();\n    }\n\n    paramConfig() {}\n\n    registerHandler(name, handler, options) {\n      options = options || {\n        maxTry: 50\n      };\n\n      handler = handler || (config => this.request(config));\n\n      this.AckQue.registerHandler(name, handler);\n      return this;\n    }\n\n    getQue(name) {\n      return this.AckQue.get(name);\n    }\n\n    getCache(name) {\n      return this.AckCache.get(name);\n    }\n\n    processQue(name) {\n      this.AckQue.paramHandler(name, config => this._fetch(config));\n      return this.AckQue.processQue(name);\n    }\n\n    clearQue(name) {\n      return this.AckQue.clear(name);\n    }\n\n    clearCache(name) {\n      return this.AckCache.clear(name);\n    }\n\n    request(config) {\n      const defaults = Object.assign({}, this.config.$http);\n      defaults.headers = Object.assign({}, this.config.$http.headers);\n      const request = Object.assign(defaults, config || {});\n      request.url = (this.config.baseUrl || '') + request.url;\n\n      if (request.offlineModel) {\n        return this.requestOfflineModel(request);\n      }\n\n      return this._fetch(request);\n    }\n\n    getCacheByNamedRequest(request) {\n      const offlineModel = request.offlineModel;\n      return this.AckCache.get(offlineModel.name, offlineModel).then(routes => {\n        routes = routes || {};\n        const cacheName = this.getStorageNameByRequest(request);\n        return routes[cacheName];\n      }).then(cache => this.processCacheGet(cache, request));\n    }\n\n    getStorageNameByRequest(request) {\n      if (request.params) {\n        const paramKeys = Object.keys(request.params);\n        if (!paramKeys.length) return request.url;\n        let url = request.url + (request.url.search(/\\?/) >= 0 ? \"&\" : \"?\");\n        paramKeys.sort().forEach(name => url += name + \"=\" + request.params[name] + \"&\");\n        return url.substring(0, url.length - 1);\n      }\n\n      return request.url;\n    }\n\n    requestOfflineModel(request) {\n      let offlineModel = request.offlineModel;\n\n      if (offlineModel && offlineModel.constructor == String) {\n        request.offlineModel = offlineModel = {\n          name: request.offlineModel\n        };\n      }\n\n      if (request.method === \"GET\") {\n        return this.getCacheByNamedRequest(request);\n      }\n\n      this.AckQue.paramHandler(offlineModel.name, config => this._fetch(config));\n      return this._fetch(request).catch(e => this.postRequestFail(e, request));\n    }\n\n    processCacheGet(cache, cfg) {\n      if (cache == null) return this._fetch(cfg);\n      const offlineModel = cfg.offlineModel;\n      return this.AckCache.cacheToReturn(offlineModel.name, cache, offlineModel).then(rtn => {\n        const willExpire = this.AckCache.optionsKillCache(offlineModel);\n\n        if (rtn && !willExpire) {\n          console.log(\"AckApi fetched cache that will never expire. Set offlineModel.expires=0 or offlineModel.maxAge=0 to avoid this message\", rtn);\n        }\n\n        if (rtn != null) {\n          return rtn;\n        }\n\n        return this._fetch(cfg);\n      });\n    }\n\n    postRequestFail(e, request) {\n      const saveWorthy = e.status == 0 || e.status == -1 || e.status == 503;\n      if (!saveWorthy) return Promise.reject(e);\n      request.sendFailMeta = request.sendFailMeta || {};\n      request.sendFailMeta.offlineId = Date.now();\n      request.sendFailMeta.lastAttempt = new Date();\n      request.sendFailMeta.attempts = request.sendFailMeta.attempts == null ? 1 : ++request.sendFailMeta.attempts;\n      request.sendFailMeta.maxTry = request.sendFailMeta.maxTry || 50;\n      const tryAgainLater = request.sendFailMeta.maxTry && request.sendFailMeta.attempts <= request.sendFailMeta.maxTry;\n      e.sendFailMeta = request.sendFailMeta;\n\n      if (tryAgainLater) {\n        const requestSave = Object.assign({}, request);\n        delete requestSave.offlineModel;\n        const offlineModel = request.offlineModel;\n        return this.AckQue.set(offlineModel.name, requestSave).then(() => Promise.reject(e));\n      }\n\n      return Promise.reject(e);\n    }\n\n    _fetch(cfg) {\n      upgradeConfig(cfg);\n      const cfgPlus = Object.assign({}, cfg);\n\n      if (cfg.params) {\n        cfgPlus.params = new HttpParams({\n          fromObject: cfg.params\n        });\n      }\n\n      if (cfg.headers) {\n        cfgPlus.headers = new HttpHeaders(cfg.headers);\n      }\n\n      const request = new HttpRequest(cfg.method, cfg.url, cfg.body, cfgPlus);\n\n      const promise = (resolve, reject) => {\n        let resolved = false;\n        this.Request.emit(request);\n        const req = this.HttpClient.request(request).subscribe(event => {\n          if (event.type === HttpEventType.Response) {\n            resolved = true;\n            resolve(event);\n          }\n        }, err => {\n          resolved = true;\n          reject(err);\n        });\n\n        if (cfg.timeout) {\n          setTimeout(() => {\n            if (resolved) return;\n            req.unsubscribe();\n            const timeoutError = new TimeOutError();\n            Object.assign(timeoutError, request);\n            timeoutError.timeout = cfg.timeout;\n            reject(timeoutError);\n          }, cfg.timeout);\n        }\n      };\n\n      return new Promise(promise).then(response => this.processFetchByConfig(response, cfg)).catch(e => this.httpFailByConfig(e, cfg));\n    }\n\n    processFetchByConfig(response, request) {\n      this.response.emit(response);\n      const data = response.body || response[\"_body\"];\n      const isJson = data && response.headers.get(\"Content-Type\") == \"application/json\";\n\n      if (isJson && !response[\"data\"]) {\n        try {\n          response[\"data\"] = JSON.parse(data);\n        } catch (e) {}\n      }\n\n      response[\"data\"] = data;\n      const isDataMode = !request.promise || request.promise == \"data\";\n      const output = isDataMode ? data : response;\n      const isCacheReponse = request.method === \"GET\" && request.offlineModel;\n\n      if (isCacheReponse) {\n        return this.requestResponseToCache(request, output).then(() => output);\n      }\n\n      return Promise.resolve(output);\n    }\n\n    httpFailByConfig(e, cfg) {\n      const isReduceData = cfg.catch == null || cfg.catch == \"data\";\n      const data = e[\"data\"];\n      const isCatchData = isReduceData && data && data.error;\n\n      if (isCatchData) {\n        const newError = new Error();\n        Object.assign(newError, e[\"data\"].error);\n        e = newError;\n      }\n\n      e[\"method\"] = e[\"method\"] || cfg.method;\n\n      if (e[\"status\"] == 401) {\n        this.AuthError.emit(e);\n      } else {\n        this.ApiError.emit(e);\n      }\n\n      return Promise.reject(e);\n    }\n\n    requestResponseToCache(request, output) {\n      var _a;\n\n      const cachename = ((_a = request.offlineModel) === null || _a === void 0 ? void 0 : _a.name) || request.offlineModel;\n      return this.AckCache.get(cachename).then(routes => {\n        routes = routes || {};\n        const cacheName = this.getStorageNameByRequest(request);\n        routes[cacheName] = {\n          cache: output\n        };\n        this.AckCache.dataOptionsCache(routes[request.url], request.offlineModel, output);\n        return routes;\n      }).then(routes => this.AckCache.set(cachename, routes));\n    }\n\n    get(path, config) {\n      const cfg = Object.assign({}, config);\n      cfg.method = \"GET\";\n      cfg.url = path;\n      return this.request(cfg);\n    }\n\n    post(path, data, config) {\n      const cfg = Object.assign({}, config);\n      cfg.method = \"POST\";\n      cfg.body = data;\n      cfg.url = path;\n      return this.request(cfg);\n    }\n\n    delete(path, config) {\n      const cfg = Object.assign({}, config);\n      cfg.method = \"DELETE\";\n      cfg.url = path;\n      return this.request(cfg);\n    }\n\n    put(path, data, config) {\n      const cfg = Object.assign({}, config);\n      cfg.method = \"PUT\";\n      cfg.body = data;\n      cfg.url = path;\n      return this.request(cfg);\n    }\n\n  }\n\n  AckApi.ɵfac = function AckApi_Factory(t) {\n    return new (t || AckApi)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  AckApi.ɵprov = i0.ɵɵdefineInjectable({\n    token: AckApi,\n    factory: AckApi.ɵfac\n  });\n  return AckApi;\n})();\n\nfunction upgradeConfig(cfg) {\n  cfg.method = cfg.method || \"GET\";\n  cfg.reportProgress = cfg.reportProgress || false;\n\n  if (cfg.params) {\n    for (let key in cfg.params) {\n      if (cfg.params[key] == null) {\n        cfg.params[key] = \"\";\n      }\n    }\n  }\n\n  return cfg;\n}","map":null,"metadata":{},"sourceType":"module"}