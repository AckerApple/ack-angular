{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Optional, Inject, Input, Output, NgModule } from '@angular/core';\nimport * as i1 from 'ngx-page-scroll-core';\nimport { NgxPageScrollCoreModule } from 'ngx-page-scroll-core';\nimport * as i2 from '@angular/router';\nimport { NavigationEnd, NavigationError, NavigationCancel } from '@angular/router';\nimport { DOCUMENT } from '@angular/common';\nimport { filter, take } from 'rxjs/operators';\n/* eslint-disable @angular-eslint/no-host-metadata-property, @angular-eslint/directive-selector */\n\nlet NgxPageScrollDirective = /*#__PURE__*/(() => {\n  class NgxPageScrollDirective {\n    constructor(pageScrollService, router, document) {\n      this.pageScrollService = pageScrollService;\n      this.router = router;\n      this.pageScrollAdjustHash = false;\n      this.pageScrollFinish = new EventEmitter();\n      this.document = document;\n    }\n\n    ngOnChanges(changes) {\n      // Some inputs changed, reset the pageScrollInstance\n      this.pageScrollInstance = undefined;\n    }\n\n    ngOnDestroy() {\n      if (this.pageScrollInstance) {\n        this.pageScrollService.stop(this.pageScrollInstance);\n      }\n    }\n\n    getPageScrollTarget() {\n      return this.pageScrollTarget || this.href || (this.fragment ? '#' + this.fragment : '');\n    }\n\n    generatePageScrollInstance() {\n      if (this.pageScrollInstance === undefined || this.pageScrollInstance === null) {\n        const options = {\n          document: this.document,\n          scrollTarget: this.getPageScrollTarget()\n        };\n\n        if (this.pageScroll) {\n          options.namespace = this.pageScroll;\n        }\n\n        if (this.pageScrollHorizontal !== undefined && this.pageScrollHorizontal !== null) {\n          options.verticalScrolling = !this.pageScrollHorizontal;\n        }\n\n        if (this.pageScrollOffset !== undefined && this.pageScrollOffset !== null) {\n          options.scrollOffset = this.pageScrollOffset;\n        }\n\n        if (this.pageScrollInterruptible !== undefined && this.pageScrollInterruptible !== null) {\n          options.interruptible = this.pageScrollInterruptible;\n        }\n\n        if (this.pageScrollInView !== undefined && this.pageScrollInView !== null) {\n          options.scrollInView = this.pageScrollInView;\n        }\n\n        if (this.pageScrollEasing) {\n          options.easingLogic = this.pageScrollEasing;\n        }\n\n        if (this.pageScrollDuration !== undefined && this.pageScrollDuration !== null) {\n          options.duration = this.pageScrollDuration;\n        }\n\n        if (this.pageScrollSpeed !== undefined && this.pageScrollSpeed !== null) {\n          options.speed = this.pageScrollSpeed;\n        }\n\n        if (this.pageScrollFinish) {\n          options.scrollFinishListener = this.pageScrollFinish;\n        }\n\n        this.pageScrollInstance = this.pageScrollService.create(options);\n      }\n\n      return this.pageScrollInstance;\n    }\n\n    pushRouterState() {\n      if (this.pageScrollAdjustHash && typeof this.pageScrollInstance.pageScrollOptions.scrollTarget === 'string' && this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(0, 1) === '#') {\n        // \"Navigate\" to the current route again and this time set the fragment/hash\n        this.router.navigate([], {\n          fragment: this.pageScrollInstance.pageScrollOptions.scrollTarget.substr(1),\n          queryParamsHandling: 'preserve'\n        });\n      }\n    }\n\n    scroll() {\n      const pageScrollInstance = this.generatePageScrollInstance();\n      this.pushRouterState();\n      this.pageScrollService.start(pageScrollInstance);\n    }\n\n    handleClick(clickEvent) {\n      if (this.routerLink && this.router !== null && this.router !== undefined) {\n        let urlTree;\n\n        if (typeof this.routerLink === 'string') {\n          urlTree = this.router.parseUrl(this.routerLink);\n        } else {\n          urlTree = this.router.createUrlTree(this.routerLink);\n        }\n\n        if (!this.router.isActive(urlTree, true)) {\n          // We need to navigate their first.\n          // Navigation is handled by the routerLink directive so we only need to listen for route change\n          this.router.events.pipe(filter(routerEvent => {\n            // We're only interested in successful navigations or when the navigation fails\n            return routerEvent instanceof NavigationEnd || routerEvent instanceof NavigationError || routerEvent instanceof NavigationCancel;\n          }), // Consume only one event, automatically \"unsubscribing\" from the event stream afterwards\n          take(1)).subscribe(routerEvent => {\n            if (routerEvent instanceof NavigationEnd) {\n              // use a timeout to start scrolling as soon as the stack is cleared\n              setTimeout(() => {\n                this.scroll();\n              }, 0);\n            }\n          });\n          return false; // to preventDefault()\n        }\n      }\n\n      this.scroll();\n      return false; // to preventDefault()\n    }\n\n  }\n\n  NgxPageScrollDirective.ɵfac = function NgxPageScrollDirective_Factory(t) {\n    return new (t || NgxPageScrollDirective)(i0.ɵɵdirectiveInject(i1.PageScrollService), i0.ɵɵdirectiveInject(i2.Router, 8), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  NgxPageScrollDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NgxPageScrollDirective,\n    selectors: [[\"\", \"pageScroll\", \"\"]],\n    hostBindings: function NgxPageScrollDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NgxPageScrollDirective_click_HostBindingHandler($event) {\n          return ctx.handleClick($event);\n        });\n      }\n    },\n    inputs: {\n      routerLink: \"routerLink\",\n      href: \"href\",\n      fragment: \"fragment\",\n      pageScrollTarget: \"pageScrollTarget\",\n      pageScrollHorizontal: \"pageScrollHorizontal\",\n      pageScrollOffset: \"pageScrollOffset\",\n      pageScrollDuration: \"pageScrollDuration\",\n      pageScrollSpeed: \"pageScrollSpeed\",\n      pageScrollEasing: \"pageScrollEasing\",\n      pageScrollInterruptible: \"pageScrollInterruptible\",\n      pageScrollInView: \"pageScrollInView\",\n      pageScrollAdjustHash: \"pageScrollAdjustHash\",\n      pageScroll: \"pageScroll\"\n    },\n    outputs: {\n      pageScrollFinish: \"pageScrollFinish\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return NgxPageScrollDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NgxPageScrollModule = /*#__PURE__*/(() => {\n  class NgxPageScrollModule {}\n\n  NgxPageScrollModule.ɵfac = function NgxPageScrollModule_Factory(t) {\n    return new (t || NgxPageScrollModule)();\n  };\n\n  NgxPageScrollModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxPageScrollModule\n  });\n  NgxPageScrollModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [NgxPageScrollCoreModule]\n  });\n  return NgxPageScrollModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of ngx-page-scroll\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxPageScrollDirective, NgxPageScrollModule }; //# sourceMappingURL=ngx-page-scroll.mjs.map","map":null,"metadata":{},"sourceType":"module"}