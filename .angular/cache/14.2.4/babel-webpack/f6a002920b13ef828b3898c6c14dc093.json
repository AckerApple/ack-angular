{"ast":null,"code":"import { AckOffline } from './AckOffline';\nimport * as i0 from \"@angular/core\";\nexport let AckCache = /*#__PURE__*/(() => {\n  class AckCache extends AckOffline {\n    constructor() {\n      super(...arguments);\n      this.prefix = \"offline-cache\";\n    }\n\n    validate(data, config) {\n      const exists = data !== null && typeof data.cache !== \"undefined\";\n      return exists && !this.hasExpired(data._timestamp, data.expires || config.expires);\n    }\n\n    optionsKillCache(options) {\n      return options.maxAge == null && options.expires == null ? false : true;\n    }\n\n    hasMaxAged(stamp, maxAge) {\n      const diff = Date.now() - maxAge;\n      const expired = stamp <= diff;\n      return maxAge && expired ? true : false;\n    }\n\n    hasExpired(_stamp, expires) {\n      const expired = Date.now() >= new Date(expires).getTime();\n      return expires && expired ? true : false;\n    }\n\n    param(name, options = {}) {\n      options.param = options.param || [];\n      return this.getCache(name, options);\n    }\n\n    paramCache(name, options) {\n      return this.param(name, options);\n    }\n\n    paramSave(name, options) {\n      return this.paramCache(name, options).then(items => this.setCache(name, items));\n    }\n\n    paramSaveCache(name, options) {\n      return this.paramSave(name, options);\n    }\n\n    cacheToReturn(name, data, options) {\n      if (data.cache == null && data._timestamp == null) {\n        return Promise.resolve(data);\n      }\n\n      const expires = data.expires || options.expires;\n      const maxAge = data.maxAge || options.maxAge;\n\n      if (options.allowExpired || !expires && !maxAge) {\n        return Promise.resolve(data.cache);\n      }\n\n      const expired = expires && this.hasExpired(data._timestamp, expires);\n      const isMaxed = maxAge && this.hasMaxAged(data._timestamp, maxAge);\n\n      if (expired || isMaxed) {\n        return this.selfDestructData(name, data).then(() => {\n          if (options.param) return Promise.resolve(options.param);\n        });\n      }\n\n      return Promise.resolve(data['cache']);\n    }\n\n    selfDestructData(name, data) {\n      if (this.dataDestructReady(data)) return this.clear(name);\n      return Promise.resolve();\n    }\n\n    dataDestructReady(data) {\n      const isMemMaxed = data.maxAge && this.hasMaxAged(data['_timestamp'], data['maxAge']);\n      const isMemExpired = data.expires && this.hasExpired(data['_timestamp'], data['expires']);\n      return isMemMaxed || isMemExpired;\n    }\n\n    get(name, options = {}) {\n      return super.get(name).then(data => {\n        if (data) {\n          return this.cacheToReturn(name, data, options);\n        }\n\n        if (options.param) return options.param;\n        return;\n      });\n    }\n\n    getCache(name, options) {\n      return this.get(name, options);\n    }\n\n    dataOptionsCache(allCache, options = {}, cache) {\n      const newOptions = {};\n      newOptions._timestamp = Date.now();\n      if (options.expires) newOptions.expires = options.expires;\n      if (options.maxAge) newOptions.maxAge = options.maxAge;\n      allCache = allCache && allCache.constructor != String ? allCache : {};\n      Object.assign(allCache, newOptions);\n\n      if (cache && cache.constructor == String) {\n        allCache.cache = cache;\n      } else if (allCache.cache && allCache.cache.constructor != String) {\n        Object.assign(allCache.cache, cache);\n      } else {\n        allCache.cache = cache;\n      }\n\n      return allCache;\n    }\n\n    set(name, cache, options = {}) {\n      options.name = options.name || name;\n      return super.get(name).then(allCache => this.dataOptionsCache(allCache, options, cache)).then(data => super.set(name, data));\n    }\n\n    setCache(name, cache, options) {\n      return this.set(name, cache, options);\n    }\n\n  }\n\n  AckCache.ɵfac = function () {\n    let ɵAckCache_BaseFactory;\n    return function AckCache_Factory(t) {\n      return (ɵAckCache_BaseFactory || (ɵAckCache_BaseFactory = i0.ɵɵgetInheritedFactory(AckCache)))(t || AckCache);\n    };\n  }();\n\n  AckCache.ɵprov = i0.ɵɵdefineInjectable({\n    token: AckCache,\n    factory: AckCache.ɵfac\n  });\n  return AckCache;\n})();","map":null,"metadata":{},"sourceType":"module"}